<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-关于SimBot的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/%E5%85%B3%E4%BA%8ESimBot%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-03-09T14:25:13.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/%E5%85%B3%E4%BA%8ESimBot%E7%9A%84%E5%AD%A6%E4%B9%A0/">关于SimBot的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="近期总结"><a href="#近期总结" class="headerlink" title="近期总结"></a>近期总结</h2><p>自从去年入职京东，当了好久的咸鱼了，体验了接近007的工作生活，又没有什么技术性的东西。有做的内容也都是围绕着BadUsb以及一些自己所需的内容开发,技术好久没有更新，并且很多东西逐渐遗忘，连这个个人博客都大半年没维护了，现在开始，需要给自己定个目标，定时抽出午睡时间去学习一些新技术，先把Redis看完，每周末更新一次博客，写笔记，然后把项目维护好。</p>
<h2 id="关于SimBot前言"><a href="#关于SimBot前言" class="headerlink" title="关于SimBot前言"></a>关于SimBot前言</h2><p>这期主要是关于SimBot的学习，因为在当地，大多数商家使用微信来与京东营业部人员、商服对接，满足日常的工作需求。但很多时候商家需要询问营业部人员的事很多是已经有公告文档，商家作为消费者，不愿去自主学习那些东西或者是不确定文档是否有更新，导致成了要用的时候，便询问营业部人员或者商服，增加不必要的工作负担。并且有些时候，没及时对商家进行一个回复，商家体验度不好。 从该处出发，便想自己做一个可以实时盯着商家微信群，及时处理商家问题的工具，这时候便使用的SimBot。SimBot是一个关于QQ、微信等聊天工具的一个机器人框架，有着一系列对这些聊天工具的操作类，但其需要有特定的对接软件，例如QQ使用的是QQmini，微信使用的是可爱猫+HttpApi。<strong>本文主要是编写对于微信的开发。</strong></p>
<h3 id="关于SimBot对微信机器人开发环境搭建"><a href="#关于SimBot对微信机器人开发环境搭建" class="headerlink" title="关于SimBot对微信机器人开发环境搭建"></a>关于SimBot对微信机器人开发环境搭建</h3><p>SimBot对于微信的开发需要先下载可爱猫+HttpApi插件，我这里使用的是4.4.0版本的可爱猫。</p>
<p>开发环境搭建：链接：<a href="https://pan.baidu.com/s/1tfJdSyv9Mtn_VemfwGsYfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tfJdSyv9Mtn_VemfwGsYfA</a><br>提取码：1458<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>
<p>这个压缩包里面已经带了插件了，但是因为可爱猫是易语言编写的，会报错，第一次下载需要将可爱猫丢进杀毒软件的白名单。</p>
<p>可爱猫也需要对应的版本，根据提示下载即可，然后把<strong>微信自动更新</strong>给关了。<br>先运行点歌插件，看一下可爱猫环境是否异常，再开始配置HttpApi插件。<br>可爱猫也有搭载日志模块，可以再日志中看运行的问题</p>
<h4 id="HttpApi插件配置"><a href="#HttpApi插件配置" class="headerlink" title="HttpApi插件配置"></a>HttpApi插件配置</h4><p>HttpApi插件配置是整个整理关键的一步，如果配置错误会导致SimBot运行起来无法与可爱猫对接，所以需要注意这个。<br>HttpApi需要配置的几个：<br>1、<strong>本地服务设置</strong>，API地址的端口，这个是涉及到之后关于SimBot搭建的配置，通过这个端口去获取微信机器人。<br>2、<strong>消息推送配置</strong>，这个配置是SimBot于HttpAoi一个信息的回传，也是后面使用SimBot获取消息、发送消息的关键配置，这个地址一般需要等simBot跑起来才可以去eclipse的开发环境查看地址，获取填充进去，也可以提前预设，但是如果没有使用SpringBoot搭建的SimBot，IP地址每次运行都会有一定变化，所以需要注意。</p>
<h3 id="SimBot在JAVA中的搭建"><a href="#SimBot在JAVA中的搭建" class="headerlink" title="SimBot在JAVA中的搭建"></a>SimBot在JAVA中的搭建</h3><p>SimBot搭建，第一步，先配置POM文件，具体POM配置可以参考：<a href="https://www.yuque.com/simpler-robot/simpler-robot-doc/czcli0" target="_blank" rel="noopener">https://www.yuque.com/simpler-robot/simpler-robot-doc/czcli0</a>   ，不多描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;simbot.version&gt;2.0.1&lt;&#x2F;simbot.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!-- 通过parent进行版本控制。当然，也可以直接放到 parent 标签中。 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;love.forte.simple-robot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;simbot.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- 可爱猫组件依赖。如果使用版本控制，则不需要填写version。 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;love.forte.simple-robot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;component-lovelycat-httpapi&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!-- compiler plugin. --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;8&lt;&#x2F;target&gt;</span><br><span class="line">                    &lt;compilerArgs&gt;</span><br><span class="line">                        &lt;arg&gt;-parameters&lt;&#x2F;arg&gt;</span><br><span class="line">                    &lt;&#x2F;compilerArgs&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;!-- 打包插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;test.Test&lt;&#x2F;mainClass&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<p>POM依赖需要注意的一点是，不要配错，配错容易项目跑不起来</p>
<p>POM依赖引入完，接下来就是关键的配置，配置如果配错，常见问题就是端口对接不上、微信号对接不上，导致的项目跑步起来<br><strong>配置文档：</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">simbot:</span></span><br><span class="line">  <span class="attr">core:</span></span><br><span class="line">    <span class="attr">bots:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">微信编号:http://127.0.0.1:88/httpAPI</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  <span class="attr">component:</span></span><br><span class="line">    <span class="attr">lovelycat:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/send</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">api:</span></span><br><span class="line">        <span class="attr">cache:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">duration:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">durationUnit:</span> <span class="string">SECONDS</span></span><br></pre></td></tr></table></figure>

<p>具体配置过程参考：<a href="https://www.yuque.com/simpler-robot/simpler-robot-doc/ygx7be" target="_blank" rel="noopener">https://www.yuque.com/simpler-robot/simpler-robot-doc/ygx7be</a><br>这个配置主要要提到<strong>bots</strong>以及<strong>lovelycat</strong>的配置。<br>第一个<strong>bot</strong>的配置主要是获取机器人的所在端口，微信编号通过可爱猫的账号登录处的wxid获取，IP地址则是在HttpApi中获取，那个对应里面的<strong>本地服务设置</strong>获取。而<strong>lovelycat</strong>的配置则是控制项目跑起来以后会存在于哪个端口，后期需要于可爱猫中的HttpApi的<strong>消息推送</strong>地址匹配，项目才能接收的到来自机器人的内容。</p>
<h2 id="创建启动类以及监听"><a href="#创建启动类以及监听" class="headerlink" title="创建启动类以及监听"></a>创建启动类以及监听</h2><p>当所有配置配置完以后，下一步要创建启动类了，启动类的创建参考：<a href="https://www.yuque.com/simpler-robot/simpler-robot-doc/oq9ex6" target="_blank" rel="noopener">https://www.yuque.com/simpler-robot/simpler-robot-doc/oq9ex6</a>  。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> steward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.annotation.SimbotApplication;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.core.SimbotApp;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.core.SimbotContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SimbotApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stewardmain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">final</span> SimbotContext context = SimbotApp.run(stewardmain<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动类创建完以后就是创建一个监听器，参考：<a href="https://www.yuque.com/simpler-robot/simpler-robot-doc/qmpgzt" target="_blank" rel="noopener">https://www.yuque.com/simpler-robot/simpler-robot-doc/qmpgzt</a>  当这两个创建好，运行一下项目，然后获取一下项目启动的远端、端口，将其配置到可爱猫的HttpApi中，然后再拿个微信号测试一下，看一下是否正常运行即可。<br><strong>监听器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> steward.listen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> love.forte.common.ioc.annotation.Beans;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.annotation.Filter;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.annotation.OnGroup;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.annotation.OnPrivate;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.api.message.events.GroupMsg;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.api.message.events.PrivateMsg;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.api.sender.MsgSender;</span><br><span class="line"><span class="keyword">import</span> love.forte.simbot.filter.MatchType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Beans</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听私聊消息并复读。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnPrivate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">privateMsg</span><span class="params">(PrivateMsg privateMsg, MsgSender sender)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MsgSender中存在三大送信器，以及非常多的重载方法。</span></span><br><span class="line">    	System.err.println(<span class="string">"接收测试1"</span>);</span><br><span class="line">    	System.err.println(privateMsg);</span><br><span class="line">    	System.err.println(privateMsg.getMsgContent());</span><br><span class="line">        sender.SENDER.sendPrivateMsg(privateMsg, <span class="string">"完成接收"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnPrivate</span></span><br><span class="line">    <span class="meta">@Filter</span>(value = <span class="string">"计算运费"</span>, matchType = MatchType.STARTS_WITH)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchcount</span><span class="params">(PrivateMsg privateMsg, MsgSender sender)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MsgSender中存在三大送信器，以及非常多的重载方法。</span></span><br><span class="line">    	System.err.println(<span class="string">"接收测试1"</span>);</span><br><span class="line">    	System.err.println(privateMsg);</span><br><span class="line">    	</span><br><span class="line">    	System.err.println(privateMsg.getMsgContent());</span><br><span class="line">        sender.SENDER.sendPrivateMsg(privateMsg, <span class="string">"完成接收"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听消息开头为 "mua" 或者 "hi" 的消息并复读。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnGroup</span></span><br><span class="line">    <span class="meta">@Filter</span>(value = <span class="string">"mua"</span>, matchType = MatchType.STARTS_WITH)</span><br><span class="line">    <span class="meta">@Filter</span>(value = <span class="string">"hi"</span>, matchType = MatchType.STARTS_WITH)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">groupMsg</span><span class="params">(GroupMsg groupMsg, MsgSender sender)</span> </span>&#123;</span><br><span class="line">    	System.err.println(<span class="string">"接收测试"</span>);</span><br><span class="line">        sender.SENDER.sendGroupMsg(groupMsg, groupMsg.getMsgContent());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上内容，就已经可以创建出一个可以跑起来的项目的，具体拓展还是要参考SimBot的文档：<a href="https://www.yuque.com/simpler-robot/simpler-robot-doc/qeyorq" target="_blank" rel="noopener">https://www.yuque.com/simpler-robot/simpler-robot-doc/qeyorq</a>  ，里面有提供丰富的关于SimBot的内容，其中主体均为SimBot，组件为SimBot的拓展，需要SimBot在哪个聊天工具上跑选择对应组件去配置对应的POM依赖和修改对应的配置即可。</p>
<h2 id="关于SimBot在SpringBoot中搭建"><a href="#关于SimBot在SpringBoot中搭建" class="headerlink" title="关于SimBot在SpringBoot中搭建"></a>关于SimBot在SpringBoot中搭建</h2><p>SimBot在SpringBoot中搭建，前面的依赖、配置都需要更换，而且需要注意SimBot的日志冲突问题，加上后面整合到了SpringBoot中以后，会存在很多的依赖冲突、配置冲突问题，目前要整合上去需要重新再学习一边SimBot1文档，里面有些零零散散的描述。下一步的目标也是将该项目使用SpringBoot去整合。再搭建出一个完整的项目运行（springBoot实在太舒服了，没SpringBoot都感觉缺少了灵魂了）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/03/09/%E5%85%B3%E4%BA%8ESimBot%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="ckm3bxqhg0000hwu34ad9ag83" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-“VUE的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/30/%E2%80%9CVUE%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-30T10:06:00.000Z" itemprop="datePublished">2020-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/30/%E2%80%9CVUE%E7%9A%84%E5%AD%A6%E4%B9%A0/">“VUE的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue只负责视图层"><a href="#Vue只负责视图层" class="headerlink" title="Vue只负责视图层"></a>Vue只负责视图层</h1><p>  Soc：<br>   Html+CSS+JS:视图：只给用户看，刷新后台的数据</p>
<h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h2><p>   网络通信：axios<br>   页面跳转：bue-router<br>   状态管理：vuex<br>   Vue-UI：ICE</p>
<p>   虚拟DOM：利用内存<br>   计算机属性–》Vue特色</p>
<h2 id="关于前后端分离"><a href="#关于前后端分离" class="headerlink" title="关于前后端分离"></a>关于前后端分离</h2><p>  前端需要前端的框架，后端需要后端的框架。早期前后端没分离，前端程序员开发完Html丢后端套模板。实现了前后端分离，后端工程师只需要提供接口与前端对接即可，增加了开发效率。接口参考Swagger文章。前端可以脱离后端独立运行，就是前后端分离的具体表现。</p>
<p>  集大成者：MVVM+Dom</p>
<p>  大前端时代：后端：变轻松，但之后需要了解分布式，微服务，大数据。</p>
<h2 id="前端为主的MV-模式"><a href="#前端为主的MV-模式" class="headerlink" title="前端为主的MV*模式"></a>前端为主的MV*模式</h2><ul>
<li>MVC（同步通信为主）：model、View、Controller</li>
<li>MVP（异步通信为主）：Model、View、Presenter</li>
<li>MVVM (异步通信为主)：model、view、BiewModel</li>
</ul>
<h2 id="前后端分离的优点："><a href="#前后端分离的优点：" class="headerlink" title="前后端分离的优点："></a>前后端分离的优点：</h2><ul>
<li>前后端职责很清晰：前端工作在浏览器端，后端工作在服务端。清晰分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑处理，输出RESful等接口</li>
<li>前端开发的复杂度可控：前端代码很重，但合理分层，让前端代码能各司其职</li>
<li>部署相对独立：可快速改进产品体验</li>
</ul>
<h2 id="前后端分离的缺点："><a href="#前后端分离的缺点：" class="headerlink" title="前后端分离的缺点："></a>前后端分离的缺点：</h2><ul>
<li>代码不能复用，比如后端开发依旧需要对数据做各种校验，校验逻辑无法复用浏览器端代码。如果可以复用，那么后端的数据校验可以相对简单化。</li>
<li>全异步，对SEO（搜索引擎优化）不利，往往需要服务端做同步渲染的降低方案。</li>
<li>性能并非最佳，特别是移动互联网环境下。</li>
<li>SPA不能满足左右需求，依旧存在大量多页面应用。URL Design需要后端配合，前端无法完全掌控。</li>
</ul>
<h2 id="NodeJS带来的全栈时代"><a href="#NodeJS带来的全栈时代" class="headerlink" title="NodeJS带来的全栈时代"></a>NodeJS带来的全栈时代</h2><p>  前端为主的MV*模式解决了很多问题，但是还是存在不足。随着NodeJS的兴起，JavaScript开始有能力运行在服务端，这意味着可以有一种新的研发模式</p>
<p>  基于NodeJS的全栈模块还是有很多问题</p>
<ul>
<li>需要前端对服务编程有更进一步的认识。比如TCP/IP协议等网络知识。</li>
<li>NNodeJS层与Java层的高效通信。NodeJS模式下，都在服务端，RESful HTTP通信未必高效</li>
<li>对部署，运维层面的熟练了解，需要更多的只是和实操经验</li>
<li>大量的历史遗留问题如何过渡，这是最大的问题。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  模式、技术没有好坏之分，只有适合不适合，前后端分离的开发思想主要是基于Soc，上面的种种模式，都是让前后端的职责更清晰，分工更合理高效。</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>  一套用于构建用户界面的渐进式框架，发布于2014年2月。与启发大型框架不同的是，Vue被设计为可以自底向上逐层应用。核心库只关注视图层，易于上手且便于与第三方库（vue-roter，bue-resource，vuex）或既有项目整合。<br>  Vue是MVVM模式的实现者</p>
<h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><ul>
<li><p>model： 模型层，表示JavaScript对象</p>
</li>
<li><p>View：视图层，这里表示Dom（Html操作的元素）、</p>
</li>
<li><p>ViewModel:连接属兔和数据的中间件，Vue.js就是MVVM中的该层实现者</p>
<p>在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者</p>
</li>
<li><p>ViewModel能够观察到数据的变化，并对视图对应的内容进行更新</p>
</li>
<li><p>ViewModel能够监听到视图的变化，并且通知数据发生改变<br>核心就是实现了DOM监听与数据绑定</p>
</li>
</ul>
<h2 id="为什么要用Vue-js"><a href="#为什么要用Vue-js" class="headerlink" title="为什么要用Vue.js"></a>为什么要用Vue.js</h2><ul>
<li>轻量级，体积小，压缩后只有20多KB</li>
<li>移动优先。更适合移动端，比如移动端的Touch事件</li>
<li>易上手，学习曲线平稳，文档整齐</li>
<li>吸取了Angular（模块化）和React（虚拟DOM）的长处，拥有自己独特的功能</li>
<li>开源</li>
</ul>
<h2 id="为什么要用MVVM"><a href="#为什么要用MVVM" class="headerlink" title="为什么要用MVVM"></a>为什么要用MVVM</h2><p>MVVM模式和MVC模式一样，主要目的是分离视图和模型，以下为好处</p>
<ul>
<li>低耦合：视图课独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候，View也可以不变</li>
<li>可复用：你可以把一些视图逻辑放在一个ViewModel里面，让很多的View重复这段视图逻辑</li>
<li>独立开发：开发人员可以专注于业务逻辑和数据的开发，设计人员可以专注于页面设计</li>
<li>可测试：界面素来是比较难测试的，而现在测试可以针对ViewModel来写</li>
</ul>
<h2 id="VUE常用7个属性"><a href="#VUE常用7个属性" class="headerlink" title="VUE常用7个属性"></a>VUE常用7个属性</h2><p><a href="https://www.cnblogs.com/bgwhite/p/9297221.html" target="_blank" rel="noopener">https://www.cnblogs.com/bgwhite/p/9297221.html</a></p>
<h2 id="为什么要用Axios"><a href="#为什么要用Axios" class="headerlink" title="为什么要用Axios"></a>为什么要用Axios</h2><p>  由于Vue.js是一个视图层框架，严格遵守SoC，所以不包含AJAX的通信功能，为了解决该问题，作者单独开发了一个名为vue-resource的插件，过过2.0版本后停止了该插件的维护，并推出了Axios框架，少用jQuery，因为它操作Dom太频繁！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/30/%E2%80%9CVUE%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="ckd8musiq0000msu3di0a4q1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-swagger的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/swagger%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-26T07:49:28.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/swagger%E7%9A%84%E5%AD%A6%E4%B9%A0/">swagger的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api文档在线生成器=》API文档与API定义同步更新</li>
<li>直接运行，在线测试API</li>
<li>支持多种语言</li>
<li>官网：<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></li>
</ul>
<h3 id="springboot集成"><a href="#springboot集成" class="headerlink" title="springboot集成"></a>springboot集成</h3><p>加入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;配置类</span><br><span class="line">@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问测试 ：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<h3 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h3><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean &#x2F;&#x2F;配置docket以配置Swagger具体参数</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、通过apiInfo()属性配置文档信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;配置文档信息</span><br><span class="line">private ApiInfo apiInfo()&#123;</span><br><span class="line">   Contact contact &#x3D; new Contact(&quot;联系人名字&quot;, &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span><br><span class="line">    return new ApiInfo(</span><br><span class="line">           &quot;Swagger学习&quot;, &#x2F;&#x2F; 标题</span><br><span class="line">           &quot;学习演示如何配置Swagger&quot;, &#x2F;&#x2F; 描述</span><br><span class="line">           &quot;v1.0&quot;, &#x2F;&#x2F; 版本</span><br><span class="line">           &quot;http:&#x2F;&#x2F;terms.service.url&#x2F;组织链接&quot;, &#x2F;&#x2F; 组织链接</span><br><span class="line">           contact, &#x2F;&#x2F; 联系人信息</span><br><span class="line">           &quot;Apach 2.0 许可&quot;, &#x2F;&#x2F; 许可</span><br><span class="line">           &quot;许可链接&quot;, &#x2F;&#x2F; 许可连接</span><br><span class="line">           new ArrayList&lt;&gt;()&#x2F;&#x2F; 扩展</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、Docket 实例关联上 apiInfo()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a>  看下效果；</p>
<h3 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h3><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()&#x2F;&#x2F; 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">any() &#x2F;&#x2F; 扫描所有，项目中的所有接口都会被扫描到</span><br><span class="line">none() &#x2F;&#x2F; 不扫描接口</span><br><span class="line">&#x2F;&#x2F; 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span><br><span class="line">withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">&#x2F;&#x2F; 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span><br><span class="line">withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(final String basePackage) &#x2F;&#x2F; 根据包路径扫描接口</span><br></pre></td></tr></table></figure>

<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()&#x2F;&#x2F; 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       &#x2F;&#x2F; 配置如何通过path过滤,即这里只扫描请求以&#x2F;kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;&#x2F;kuang&#x2F;**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、这里的可选值还有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">any() &#x2F;&#x2F; 任何请求都扫描</span><br><span class="line">none() &#x2F;&#x2F; 任何请求都不扫描</span><br><span class="line">regex(final String pathRegex) &#x2F;&#x2F; 通过正则表达式控制</span><br><span class="line">ant(final String antPattern) &#x2F;&#x2F; 通过ant()控制</span><br></pre></td></tr></table></figure>

<h3 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h3><h1 id="未完，先学习vue，后期再接着整理"><a href="#未完，先学习vue，后期再接着整理" class="headerlink" title="未完，先学习vue，后期再接着整理"></a>未完，先学习vue，后期再接着整理</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/swagger%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="ckd4kpm4e00015su398sxcaf6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MyBatisPlus复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/20/MyBatisPlus%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-20T14:32:57.000Z" itemprop="datePublished">2020-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/20/MyBatisPlus%E5%A4%8D%E4%B9%A0/">MyBatisplus复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MyBatis是简化数据库操作的一个框架，Plus则是增强版"><a href="#MyBatis是简化数据库操作的一个框架，Plus则是增强版" class="headerlink" title="MyBatis是简化数据库操作的一个框架，Plus则是增强版"></a>MyBatis是简化数据库操作的一个框架，Plus则是增强版</h1><p>官网：<a href="https://mp.baomidou.com/" target="_blank" rel="noopener">https://mp.baomidou.com/</a> MyBatis Plus，简化 MyBatis ！</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>无入侵</li>
<li>损耗小</li>
<li>强大的CRUD操作</li>
<li>支持Lambda形式调用</li>
<li>支持主键自动生成</li>
<li>支持 ActiveRecord 模式</li>
<li>支持自定义全局通用</li>
<li>内置代码生成器</li>
<li>内置分页插件</li>
<li>分页插件支持多种数据库</li>
<li>内置性能分析插件</li>
<li>内置全局拦截插件</li>
<li>使用该框架，Mybatisplus可以照样使用Mypatis的操作</li>
</ul>
<h3 id="入门的操作"><a href="#入门的操作" class="headerlink" title="入门的操作"></a>入门的操作</h3><ul>
<li>导入依赖</li>
<li>配置</li>
<li>编写代码 </li>
</ul>
<h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p> 雪花算法：snowﬂake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为 毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味 着每个节点在每毫秒可以产生 4096 个 ID），后还有一个符号位，永远是0。可以保证几乎全球唯 一！</p>
<h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><p>  创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！<br>阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modiﬁed几乎所有的表都要配置上！而且需 要自动化</p>
<p>操作：<br>在对应的字段上添加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字段添加填充内容</span><br><span class="line">@TableField(fill &#x3D; FieldFill.INSERT) </span><br><span class="line">private Date createTime;</span><br><span class="line"></span><br><span class="line">@TableField(fill &#x3D; FieldFill.INSERT_UPDATE) </span><br><span class="line">private Date updateTime;</span><br></pre></td></tr></table></figure>

<p>编写处理器来处理这个注解即可！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j </span><br><span class="line">@Component &#x2F;&#x2F; 一定不要忘记把处理器加到IOC容器中！</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; 插入时的填充策略</span><br><span class="line">     @Override</span><br><span class="line">      public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">           log.info(&quot;start insert fill.....&quot;);</span><br><span class="line">     this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); </span><br><span class="line">     this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 更新时的填充策略</span><br><span class="line">     @Override</span><br><span class="line">     public void updateFill(MetaObject metaObject) &#123; </span><br><span class="line">            log.info(&quot;start update fill.....&quot;);</span><br><span class="line">             this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul>
<li>乐观锁：它总是认为不会出问题，无论干什么都不去上锁，如果出现问题再次更新值测试</li>
<li>悲观锁：它总认为会出现问题，不管什么操作都是先上锁再操作</li>
</ul>
<p>乐观锁实现方式：</p>
<ul>
<li>取出记录时，获取当前 version </li>
<li>更新时，带上这个version </li>
<li>执行更新时， set version = newVersion where version = oldVersion </li>
<li>如果version不对，就更新失败</li>
</ul>
<h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>wapper  复杂的Sql就可以用它来代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test()&#123;</span><br><span class="line">&#x2F;&#x2F;查询名字是测试1的数据</span><br><span class="line">	 QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">	wapper.ea（“name”，“测试1”）;</span><br><span class="line">	User user &#x3D; userMapper.selectOne(wrapper)</span><br><span class="line">	 System.out.println(user); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/20/MyBatisPlus%E5%A4%8D%E4%B9%A0/" data-id="ckd4kpm3y00005su3dpuz78et" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL的复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/18/MySQL%E7%9A%84%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-18T01:58:14.734Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/18/MySQL%E7%9A%84%E5%A4%8D%E4%B9%A0/">MySQL的复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Mysql复习与学习<br>date: 2020-07-18 09:58:14<br>tags:</p>
<hr>
<h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><h3 id="关系类型数据库"><a href="#关系类型数据库" class="headerlink" title="关系类型数据库"></a>关系类型数据库</h3><ul>
<li>通过表和表之间，行和列之间的关系进行数据的存储</li>
<li>常见的MySQL、Oracle、DB2</li>
</ul>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ul>
<li>非关系型型数据库，对象存储，通过对象自身的属性来决定。</li>
<li>常见的有Redis、MongDB</li>
</ul>
<h1 id="DBMS（数据管理系统）"><a href="#DBMS（数据管理系统）" class="headerlink" title="DBMS（数据管理系统）"></a>DBMS（数据管理系统）</h1><ul>
<li>数据库管理软件，科学有效的管理数据、维护和获取数据；</li>
<li>Mysql，数据库管理系统</li>
<li>5.7版本属于比较稳定版本</li>
<li>8.0版本驱动与5.7不一样，所以有时候需要配置一些不同的配置</li>
</ul>
<h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">当表名或者字段名是一个特殊字符或者是关键字，就需要&#96;&#96;，例如user</span><br><span class="line"></span><br><span class="line">数据库相关的SQL</span><br><span class="line">	SHOW DATABASES;		--查看所有数据库</span><br><span class="line">	CREATE DATABASE shool;	--创建shool数据库，shool是数据库名</span><br><span class="line">	SHOW CREATE DATABASE shool	--查看shool数据库详情</span><br><span class="line">	DROP DATABASE shool;	--删除shool数据库</span><br><span class="line">	USE shool;	--使用shool数据库</span><br><span class="line"></span><br><span class="line">表相关的</span><br><span class="line">	CREATE TABLE t1 (name VARCHAR(255),age INT) CHARSET&#x3D;UTF8;	--创建表</span><br><span class="line">	SHOW TABLES;	--展示所有表</span><br><span class="line">	SHOW CREATE TABLES t1;	--查看t1表详情</span><br><span class="line">	DESC t1;	--查看t1表字段</span><br><span class="line">	DROP TABLE t1;	--删除t1表</span><br><span class="line">	RENAME TABLE t1 TO t2;	--将t1表改名为t2表</span><br><span class="line">	</span><br><span class="line">	ALTER TABLE t1 ADD id INT;	--添加字段id到表t1的最后面</span><br><span class="line">	ALTER TABLE t1 ADD id INT FIRST;	--添加id字段到t1表的最前面 </span><br><span class="line">	ALTER TABLE t1 ADD id INT AFTER name;	--添加id字段到name字段的后面</span><br><span class="line">	ALTER TABLE t1 DROP id;		--删除t1表的id字段</span><br><span class="line">	ALTER TABLE t1 CHANGE id uid INT;	--将t1表表字段id修改成uid，注意新名后面记得跟新类型</span><br><span class="line">	ALTER TABLE t1 MODIFY id VARCHAR(20); --修改约束</span><br></pre></td></tr></table></figure>
<h1 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h1><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><ul>
<li>tinyint  十分小的数据   1个字节</li>
<li>smallint  较小的数据    2个字节</li>
<li>mediumint 中等大小的数据 3个字节</li>
<li>int       标准的整数      4个字节  常用的</li>
<li>bigint    较大的数据     8个字节</li>
<li>float     浮点数         4个字节</li>
<li>double    浮点数         8个字节（精度问题）、</li>
<li>decimal   字符串形式的浮点数 金融计算一般使用该数据类型，在JAVA中也有对应的类</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>char      字符串固定大小的  0-255</li>
<li>varchar   可变字符串        0-65535     常用的，对应JAVA中的String</li>
<li>tinytext  微型文本          2^8-1</li>
<li>text      文本串            2^16-1    保存大文本，例如博客文章之类的</li>
</ul>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><ul>
<li>date      YYYY-MM-DD  日期格式</li>
<li>time      HH: mm: ss  时间格式</li>
<li>datetime  YYYY-MM-DD HH: mm: ss 最常用的时间格式   最常用的</li>
<li>timestamp 时间戳，  1970.1.1到现在的毫秒数   也是常用的</li>
<li>year      年份代表</li>
</ul>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><ul>
<li>没有值，未知</li>
<li>注意不要使用null进行计算，结果为null</li>
</ul>
<h1 id="数据库的字段属性（重点）"><a href="#数据库的字段属性（重点）" class="headerlink" title="数据库的字段属性（重点）"></a>数据库的字段属性（重点）</h1><p> Unsigned：</p>
<ul>
<li>无符号的整数</li>
<li>声明了该列表不能为负数</li>
</ul>
<p>zerfill：</p>
<ul>
<li>0填充的</li>
<li>不足的位数用0来填充，  例如： int（3）  5会变成005</li>
</ul>
<p>自增</p>
<ul>
<li>通常理解为自增，自动在上一条记录的基础上+1（默认，这是可修改的）</li>
<li>通常用来设计唯一的主键 index ，但必须是整数类型</li>
</ul>
<p>非空</p>
<ul>
<li>设置为not null，如果不给他赋值，他就会报错</li>
<li>NULL  如果不填写值，默认就是null！</li>
</ul>
<p>默认：</p>
<ul>
<li>设置默认的值！</li>
<li>sex，默认设置为男，如果不指定该列的值，就会有默认的值！</li>
</ul>
<p><strong>数据库必须要有的字段</strong><br>1、id 主键<br>2、version 乐观锁<br>3、id_delete 伪删除<br>4、gmt_create 创建时间<br>5、gmt_update 修改时间</p>
<p>每个表必须会有这五个字段，表示一个记录的存在意义</p>
<h1 id="建立字段的表的格式"><a href="#建立字段的表的格式" class="headerlink" title="建立字段的表的格式"></a>建立字段的表的格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_user (</span><br><span class="line">  uid INT AUTO_INCREMENT COMMENT &#39;用户id&#39;,</span><br><span class="line">  username VARCHAR(20) NOT NULL UNIQUE COMMENT &#39;用户名&#39;,</span><br><span class="line">  password CHAR(32) NOT NULL COMMENT &#39;密码&#39;,</span><br><span class="line">  salt CHAR(36) COMMENT &#39;盐值&#39;,</span><br><span class="line">  phone VARCHAR(20) COMMENT &#39;手机号码&#39;,</span><br><span class="line">  email VARCHAR(30) COMMENT &#39;电子邮箱&#39;,</span><br><span class="line">  gender INT(1) COMMENT &#39;性别：0-女，1-男&#39;,</span><br><span class="line">  avatar VARCHAR(100) COMMENT &#39;头像&#39;,</span><br><span class="line">  is_delete INT(1) COMMENT &#39;是否标记为删除，0-未删除，1-已删除&#39;,</span><br><span class="line">  created_user VARCHAR(20) COMMENT &#39;创建人&#39;,</span><br><span class="line">  created_time DATETIME COMMENT &#39;创建时间&#39;,</span><br><span class="line">  modified_user VARCHAR(20) COMMENT &#39;最后修改人&#39;,</span><br><span class="line">  modified_time DATETIME COMMENT &#39;最后修改时间&#39;,</span><br><span class="line">  PRIMARY KEY (uid)</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure>
<p>格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名（</span><br><span class="line">字段名 列类型 属性 索引 注释，</span><br><span class="line">字段名 列类型 属性 索引 注释，</span><br><span class="line">......</span><br><span class="line">字段名 列类型 属性 索引 注释，</span><br><span class="line">设置主键</span><br><span class="line">）设置引擎 设置字符集</span><br><span class="line"></span><br><span class="line"> password【字段名】 CHAR(32)【列类型】 NOT NULL【属性】 COMMENT &#39;密码&#39;【注释】, </span><br><span class="line"> ENGINE&#x3D;INNODB【引擎】 DEFAULT CHARSET&#x3D;utf8mb4【字符集】;</span><br></pre></td></tr></table></figure>
<h1 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h1><ul>
<li>INNODB 默认使用</li>
<li>MYISAM 早期使用<br>常规使用操作：</li>
<li>MYISAM 节约空间，速度快</li>
<li>INNODB 安全性高，支持事务的处理，由于支持外键，可以多表多用户操作</li>
</ul>
<h3 id="在物理空间存在的位置"><a href="#在物理空间存在的位置" class="headerlink" title="在物理空间存在的位置"></a>在物理空间存在的位置</h3><p>所有的数据库文件都存在data目录下<br>本质还是文件的存储！<br>Mysql 引擎在物理文件上的区别</p>
<ul>
<li>INNODB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件</li>
<li>MYISAM对应文件1、*.frm  表结构的定义文件</li>
<li>2、*.MYD   数据文件（data）</li>
<li>3、*.MYI  索引文件（index）      </li>
</ul>
<h1 id="Mysql-数据库管理"><a href="#Mysql-数据库管理" class="headerlink" title="Mysql 数据库管理"></a>Mysql 数据库管理</h1><h3 id="外键（了解即可）"><a href="#外键（了解即可）" class="headerlink" title="外键（了解即可）"></a>外键（了解即可）</h3><p>删除有外键关系表的时候，必须先删除引用别人的表（从表），在删除被引用的表（主表）<br>链接：<a href="https://pan.baidu.com/s/1rQiDEy2N4T-bmxsflQNPAQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1rQiDEy2N4T-bmxsflQNPAQ</a><br>提取码：1458</p>
<p>以上是物理级别的外键，不建议使用，了解即可</p>
<p>逻辑外键这是常见的，数据库值单纯的存表、数据即可，想要用外键，在JAVA代码中通过代码实现</p>
<h3 id="DML语言（既增删改）"><a href="#DML语言（既增删改）" class="headerlink" title="DML语言（既增删改）"></a>DML语言（既增删改）</h3><p>数据库意义：数据存储、数据管理<br>DML语言：数据操作语言</p>
<ul>
<li>insert</li>
<li>update</li>
<li>delete</li>
</ul>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO T1(name,age) values(&#39;Lilei&#39;,18),(&#39;Hanmeimei&#39;,19);</span><br><span class="line">批量插入格式: insert into 表名(字段1，字段2) values(值1,值2),(值1,值2),(值1,值2);</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>  1、字段与字段之间用 英文逗号 隔开<br>  2、字段可以省略，但是后面的值必须要一一对应，不能少<br>  3、插入多条数据，VALUES 后面的值要适应 英文逗号 隔开即可</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>update 表名 set xxx=xxx where 条件;<br>update 表名 set name=’是鸽鲨手’,age=23 WHERE id = 1;<br>第一句更改单个值，第二个更改多个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE person SET age&#x3D;30 WHERE name&#x3D;&#39;Jerry&#39;;</span><br><span class="line">UPDATE person SET age&#x3D;20 WHERE age is null;</span><br></pre></td></tr></table></figure>
<p>关于区间查询进行修改操作：<br>链接：<a href="https://pan.baidu.com/s/17iXmpuRmebheOPU9K6A7Dg" target="_blank" rel="noopener">https://pan.baidu.com/s/17iXmpuRmebheOPU9K6A7Dg</a><br>提取码：1458</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>delete from 表名 where 条件;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from person where age&#x3D;20;</span><br><span class="line">delete from person where name&#x3D;&#39;Tom&#39;;</span><br><span class="line">delete from person; 	--避免这样这，这样会清空表</span><br></pre></td></tr></table></figure>
<p>TRUNCATE命令<br>作用：完全清空一个数据库表，表的结构和索引约束不会变<br>TRUNCATE 表名；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE t1;</span><br></pre></td></tr></table></figure>

<p>TRUNCATE与delete from person的区别</p>
<ul>
<li>相同点：都能删除数据，不会删除表结构</li>
<li>不同:TRUNCATE会重新设置，自增列计数器会归零，而且不影响事务</li>
</ul>
<p>了解即可：DELETE删除的问题，重启数据库，现象</p>
<ul>
<li>INNODB 自增列会重1开始（存在内存当中，断电即失）</li>
<li>MYISAM 继续从上一个自增量开始（存在文件中，不会丢失）</li>
</ul>
<h3 id="DQL查询数据（重点）"><a href="#DQL查询数据（重点）" class="headerlink" title="DQL查询数据（重点）"></a>DQL查询数据（重点）</h3><p>DQL（Date Query LANGUAGE:数据查询语言）</p>
<ul>
<li>所有的查询操作都用它 Select</li>
<li>简单的查询，复杂的查询它都能做</li>
<li>数据库中最核心的语言，最重要的语句</li>
<li>使用频率最高的语句</li>
</ul>
<p>SELECT完整语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段</span><br><span class="line">FROM 表</span><br><span class="line">LEFT JOIN     --联合查询</span><br><span class="line">WHERE         --查询满足的条件</span><br><span class="line">GROUP BY      --指定结果按照哪个字段分组</span><br><span class="line">HAVING		  --过滤分组的记录必须满足的次要条件</span><br><span class="line">ORDER BY	  --指定查询记录按一个活多个条件排序</span><br><span class="line">LIMIT		  --指定查询记录从哪条到哪条（分页）</span><br></pre></td></tr></table></figure>

<p>指定查询字段<br>SELECT 字段 FROM 表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from person; 查询表中所有的数据</span><br><span class="line">select name from person; 查询所有的名字</span><br><span class="line">select * from person where age&gt;50; 查询年龄大于50岁的信息</span><br></pre></td></tr></table></figure>

<p>当列名不是见名知意，我们起别名 AS      （字段名 AS 别名）（表名 AS 别名）<br>效果：可以让列名或者表名查询出来后改变列或者表名，下面SQL查询出来，“student”字段会变成“学号”，”studentName“变成“学生姓名”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT student AS 学号,studentName AS 学生姓名 FROM student AS s;</span><br></pre></td></tr></table></figure>

<p>函数 CONCAT（a，b）<br>效果：下面SQL查询出来后，原本查询出来的字段只会出现学生名字（张三），添加会变成“姓名：+查询出来的studentName结果”（姓名：张三）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNCAT(&#39;姓名：&#39;,studentName) FROM student;</span><br></pre></td></tr></table></figure>
<p>去重复 DISTINCT<br>效果：去除SELECT查询出来重复的结果，只显示一条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT &#96;studentno&#96; FROM result;</span><br></pre></td></tr></table></figure>

<p>计算符号<br>效果：直接对数据进行算术操作（+，-，*，/，%）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &#96;studentno&#96;,&#39;StudentResult&#39;+1 AS 所有分数加一分 FROM result</span><br></pre></td></tr></table></figure>

<p>数据库中的表达式：文本值，列，null，函数，计算书，系统变量…<br>格式：SELECT 表达式 FROM 表</p>
<p>###where条件子句<br>作用：检索条件中符合的值<br>搜索的条件由一个或者多个表达式组成，结果为布尔值<br>效果：查询学生成绩在95到100中间的学生</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM result WHERE StrudentResult BETWEEN 95 AND 100</span><br></pre></td></tr></table></figure>
<p>符号参考“修改”下面链接的图片内容<br>逻辑符号在这里尽量更换成对应的单词使用<br>链接：<a href="https://pan.baidu.com/s/1js3W5qYHb4a60WeSScL9mw" target="_blank" rel="noopener">https://pan.baidu.com/s/1js3W5qYHb4a60WeSScL9mw</a><br>提取码：1458</p>
<h3 id="连表查询-JOIN"><a href="#连表查询-JOIN" class="headerlink" title="连表查询 JOIN"></a>连表查询 JOIN</h3><p>做连表的思路：<br>1、分析需求，分析查询的字段来自哪些表，（连表查询）<br>2、确定使用7种链接的哪种<br>确定交叉点（两个表中哪个数据是相同的）<br>判断的条件：学生表中 studentNO=成绩表 studentNo</p>
<p>连接操作<br>INNER JOIN  如果表中至少有一个匹配，就返回行<br>LEFT JOIN   会从左表返回所有值，即使右表没有匹配<br>RIGHT JOIN  会从右表返回所有值</p>
<p>where和on的区别：where先连表后筛选，on先筛选后连表<br>模棱两可的字段记得选择是哪张表的字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.studentno,studentname,subjectno,&#96;studentresult&#96;</span><br><span class="line">FROM student s</span><br><span class="line">INNER JOIN result r</span><br><span class="line">WHERE s.studentno&#x3D;r.studentno</span><br></pre></td></tr></table></figure>
<p>上面是两张表连查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT studentNO,stuentName，SubjectName，StudentResult</span><br><span class="line">FROM student s</span><br><span class="line">RIGHT JOIN result r</span><br><span class="line">ON r.studentNo&#x3D;s.studentNo</span><br><span class="line">INNER JOIN subject sub</span><br><span class="line">ON r.SubjectNo&#x3D;sub.SubjectNo</span><br></pre></td></tr></table></figure>
<p>上面三表连查</p>
<p>多表连查要点</p>
<ul>
<li>我要查询哪些数据 Select …</li>
<li>从哪些表查询 FROM 表 xxx JOIN 链接的表 ON 交叉条件</li>
<li>假设存在多张表查询，慢慢增加，先查询两张表，在查询第三张表、第四张表</li>
</ul>
<p>左链接以左表为基准，右连接以右表为基准<br>比如有一个学生数据没参加考试，用左查询查询也会将该学生查询出来（左边学生表右边考试成绩表），右查连接不会出现该学生</p>
<p>JOIN（连接的表）ON （判断条件）  连接查询<br>WHERE   等值查询</p>
<h3 id="自连接（难点、了解点、建表偷懒）"><a href="#自连接（难点、了解点、建表偷懒）" class="headerlink" title="自连接（难点、了解点、建表偷懒）"></a>自连接（难点、了解点、建表偷懒）</h3><p>将原来该分为两张表建立的数据（有主从关系的数据）建立在同一张表，建立了对应的主从ID，后期查询主从关系使用的<br>自己的表和自己的表连接，核心：一张表拆成两张一样的表（父栏目与子栏目）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.name AS 父栏目,b.name AS 子栏目</span><br><span class="line">FROM user AS a, user AS b</span><br><span class="line">WHERE a.id&#x3D;b.id</span><br></pre></td></tr></table></figure>

<h3 id="分页LIMIT与排序ORDER-BY"><a href="#分页LIMIT与排序ORDER-BY" class="headerlink" title="分页LIMIT与排序ORDER BY"></a>分页LIMIT与排序ORDER BY</h3><p>ORDER BY<br>分为升序（ASC）与降序排列（DESC）</p>
<p>分页<br>意义：缓解数据库压力、给人更好的体验  （相对于瀑布流 ‘百度查询图片出来的结果就是瀑布流’）</p>
<p>LIMIT 0,5     –从第1到第5的数据<br>0–起始的位置   5–页面的大小</p>
<p>网页应用翻页计算<br>第N页 LIMIT （n-1）*p,p</p>
<p>p：页面总大小<br>n：当前页数<br>（n-1）*p：起始值<br>数据总数/页面大小 = 总页数</p>
<p>子查询（开发慎用，会导致服务器因为查询运行变慢）<br>在where中嵌套一个查询语句</p>
<p>格式：<br>SELECT * FROM 表名 WHER  字段 in（select xxx from xxx）</p>
<h3 id="Mysql函数"><a href="#Mysql函数" class="headerlink" title="Mysql函数"></a>Mysql函数</h3><p>常用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--数学函数</span><br><span class="line">SELECT ABS(-8)  --绝对值</span><br><span class="line">SELECT CELLING(9.4)  --向上取整</span><br><span class="line">SELECT FLOOR(9.4)    --向下取整</span><br><span class="line">SELECT SIGN(10)		--盘旋一个数的符号 正数返回1，负数返回-1</span><br><span class="line"></span><br><span class="line">--字符串函数</span><br><span class="line">SELECT CHAR_LENGTH(&#39;内容&#39;)  --字符串长度</span><br><span class="line">SELECT CONCAT(&#39;内容1&#39;,&#39;内容2&#39;,&#39;内容3&#39;)   --拼接字符串</span><br><span class="line">SELECT INSERT(&#39;HELLOWORD&#39;,1,2,&#39;ABCD&#39;)   --替换，从指定位置替换某个长度</span><br><span class="line">SELECT LOWER(&#39;ABCD&#39;)  --转小写</span><br><span class="line">SELECT UPPER(&#39;asd&#39;)	--转大写</span><br><span class="line">SELECT INSTR(&#39;HELLOWORD&#39;,&#39;H&#39;)  --查询第一次出现的位置</span><br><span class="line">SELECT REPLACE(&#39;ABCDE&#39;,&#39;BC&#39;,&#39;AE&#39;)  --替换字符串</span><br><span class="line">SELECT REVERSE(&#39;ABCDE&#39;)	--翻转字符串</span><br><span class="line"></span><br><span class="line">--时间和日期函数</span><br><span class="line">SELECT CURRENT_DATE() --获取当前日期</span><br><span class="line">SELECT CURDATE()  --获取当前日期</span><br><span class="line">SELECT NOW()  --获取当前的时间</span><br><span class="line">SELECT LOCALTIME()  --本地时间</span><br><span class="line">SELECT SYSDATE()  --系统时间</span><br></pre></td></tr></table></figure>
<p>聚合函数<br>COUNT()<br>SUM()<br>AVG()<br>MAX()<br>MIN()</p>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>格式：<br>UPDATE 表名 SECT 字段名=MD5(字段名)</p>
<p>插入前加密<br>INSERT INTO 表名 VALUES(4,’字段1’,MD5(‘字段2’))</p>
<p>解密<br>SELECT * FROM 表名 WHERE 字段一=‘内容’ AND 字段二=MD5(‘内容’)</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>要么都成功，要么都失败<br>mysql是自动开启事务自动提交的</p>
<p>事务原则ACID：原子性、一致性、隔离性、持久性</p>
<ul>
<li>原子性：这两个步骤一起成功、或者一起失败，不能只有其中之一发生一个动作</li>
<li>一致性：针对两个事务操作前后的状态一致性（最终一致性），事务前后的数据完整性要保证一致性</li>
<li>持久性：事务的结束后的数据不随着外界原因导致数据丢失（事务如果没提交，恢复到原状。只要提交了，就不可逆，持久化到数据库上）</li>
<li>隔离性：多个用户同时操作，排除其他事务对当前事务的影响</li>
</ul>
<p>隔离导致的问题：</p>
<ul>
<li>脏读：一个事务读取了另外一个事务未提交的数据</li>
<li>不可重复读：在一个事务内读取某一行数据，多次读取结果不同。（不一定是错误，看场合）</li>
<li>幻读：一个事务内读到了别的事务插入的数据，导致前后读取不一致</li>
</ul>
<p>流程图以及代码<br>链接：<a href="https://pan.baidu.com/s/1OugAtEQlMQ2z0LnMkd_kng" target="_blank" rel="noopener">https://pan.baidu.com/s/1OugAtEQlMQ2z0LnMkd_kng</a><br>提取码：1458</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>MySQL官方对索引的定义：索引是帮助MySQL高效获取数据的数据结构。索引是数据结构。</p>
<p>索引的分类</p>
<ul>
<li>主键索引 （PRINARY KEY）<ul>
<li>唯一标识，不可重复，只能有一个列作为主键</li>
</ul>
</li>
<li>唯一索引  (UNIQUE KEY)<ul>
<li>避免重复的列出现，唯一索引可以重复，多个列都可以标识唯一索引</li>
</ul>
</li>
<li>常规索引  (KEY/INDEX)<ul>
<li>默认的，index，key关键字来设置</li>
</ul>
</li>
<li>全文索引  （FullText）<ul>
<li>在特定的数据库引擎下才有，MyISAM</li>
<li>快速定位数据</li>
</ul>
</li>
</ul>
<p>使用：<br>  1、在创建表的时候给字段增加索引<br>  2、创建完毕后，增加索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 显示索引</span><br><span class="line">SHOW INDEX FROM 表名</span><br><span class="line"></span><br><span class="line">-- 增加一个全文索引</span><br><span class="line">ALTER TANLE 表名 ADD FULLTEXT INDEX 索引名（列名）</span><br><span class="line">ALTER TANLE shool.student ADD FULLTEXT INDEX studentName(studentname);</span><br><span class="line"></span><br><span class="line">-- EXPLAIN 分析SQL执行的状况</span><br></pre></td></tr></table></figure>

<p>索引原则</p>
<ul>
<li>索引不是越多越好</li>
<li>不要对经常变动的数据加索引</li>
<li>不要对小数据量加索引</li>
<li>索引一般用再常用来查询的字段上</li>
</ul>
<p>索引的数据结构<br>Hash类型的索引<br>B+tree：InnoDB默认的索引</p>
<p>在不同场景下用这两个的速度不一样，Hash类型的索引使用了Hash散列算法，在单独寻找一条记录的时候会比较快，但是在范围查询没有B+tree快。</p>
<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><p>为什么要备份：</p>
<ul>
<li>保证重要的数据不丢失</li>
<li>数据转移</li>
</ul>
<p>备份方式：</p>
<ul>
<li>直接拷贝物理文件</li>
<li>在可视化工具手动导出<ul>
<li>可视化工具直接选择数据库右键即可</li>
</ul>
</li>
<li>使用命令行导出 mysqldump<ul>
<li>记得配置好环境变量才可以在CMD中导出，具体命令百度</li>
</ul>
</li>
</ul>
<p>导入：<br>** 导入表记得到对应的数据库中导入，导入数据库的话只要登录状态就可以直接登录 **</p>
<ul>
<li>source d:/文件名.sql<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source d:&#x2F;emp.sql;</span><br></pre></td></tr></table></figure>
<h1 id="权限管理和备份"><a href="#权限管理和备份" class="headerlink" title="权限管理和备份"></a>权限管理和备份</h1>用户管理<br>内容百度，这是关于对数据库操做的权限，用户能对已有的表进行多大限度的操作，这是可控制的。</li>
</ul>
<h1 id="数据库的三大规约：三大范式"><a href="#数据库的三大规约：三大范式" class="headerlink" title="数据库的三大规约：三大范式"></a>数据库的三大规约：三大范式</h1><p>** 设置数据库的意义：当数据库比较复杂的时候，我们就需要设计 **</p>
<p>糟糕的数据库设计：</p>
<ul>
<li>数据库冗余，浪费空间</li>
<li>数据库插入和删除都会麻烦、异常【屏蔽使用物理外键】</li>
<li>程序的性能差</li>
</ul>
<p>好的数据库</p>
<ul>
<li>节约空间</li>
<li>保证数据库的完整性</li>
<li>方便我们开发系统</li>
</ul>
<p>软件开发中关于数据库的设计：</p>
<ul>
<li>分析需求：分析业务需要处理的数据的需求</li>
<li>概要设计： 设计关系图E-R图</li>
</ul>
<p>为什么需要数据规范化</p>
<ul>
<li>信息重复</li>
<li>更新异常</li>
<li>插入异常<ul>
<li>无法正常显示信息</li>
</ul>
</li>
<li>删除异常<ul>
<li>丢失有效的信息</li>
</ul>
</li>
</ul>
<p>三大范式</p>
<ul>
<li>第一范式：要求数据库表的每一列是不可分割的原子数据项。保证原子性，减少歧义</li>
<li>第二范式：需要先满足第一范式。每张表只描述一件事情</li>
<li>第三范式：需要先满足前面两个范式。保证数据表中的每一列和主键都直接相关，不能间接相关。</li>
</ul>
<p>链接：<a href="https://pan.baidu.com/s/13cgFomc-aeXTGixd0_khBA" target="_blank" rel="noopener">https://pan.baidu.com/s/13cgFomc-aeXTGixd0_khBA</a><br>提取码：1458</p>
<p>规范性和性能性不可额兼得。<br>关联的查询表最好不超过3张表。</p>
<ul>
<li>考虑商业化的需求和目标（陈本，用户体验）  数据库的性能更加重要</li>
<li>在规范性能的问题的时候，需要适当考虑一下规范性！</li>
<li>故意给某些表增加一些冗余字段。（多表查询变成单表查询）</li>
<li>故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/18/MySQL%E7%9A%84%E5%A4%8D%E4%B9%A0/" data-id="ckcrb4ops00001cu30bvh8y57" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringBoot复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/17/SpringBoot%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-17T10:57:24.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/17/SpringBoot%E5%A4%8D%E4%B9%A0/">SpringBoot复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringBoot框架作用"><a href="#SpringBoot框架作用" class="headerlink" title="SpringBoot框架作用"></a>SpringBoot框架作用</h2><p>  它是一个已经完成绝大部分配置的SpringMVC框架，并且可以更简单的整合其他框架一起使用，甚至默认情况下已经集成了绝大部分通用的依赖。核心思想为“约定大于配置”，开发人员遵守相关的”约定“即可</p>
<h2 id="关于项目的创建"><a href="#关于项目的创建" class="headerlink" title="关于项目的创建"></a>关于项目的创建</h2><p>   通过 <a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 官网下载即可<br>   Group值为cn.tedu，Artifact值为sample，展开Options，将Packaging选择为war，确定无误后，点击下方的Generate按钮，将生成项目，并且开始自动下载。<br>   将下载得到的sample.zip解压，得到sample文件夹，该文件夹就是一个SpringBoot项目，先将该文件夹移动到Workspace中，便于管理项目。</p>
<h2 id="项目中添加静态资源"><a href="#项目中添加静态资源" class="headerlink" title="项目中添加静态资源"></a>项目中添加静态资源</h2><p>  静态资源：客户端可以直接访问的资源，例如.html、.css、.js、图片等。</p>
<p>  在SpringBoot项目中，在src/main/resources下有static文件夹，这个文件夹就是专门用于存放静态资源文件的，其作用相当于传统JavaEE项目中的webapp文件夹，但是，在SpringBoot项目中建议放在static中，在使用该文件夹时，还可以自行创建子级文件夹。</p>
<h2 id="关于MyBatis框架"><a href="#关于MyBatis框架" class="headerlink" title="关于MyBatis框架"></a>关于MyBatis框架</h2><p>  需要在项目中添加MyBatis的相关依赖，可以再下载时就添加，或者直接复制依赖。<br>  添加依赖后，启动项目时，就会自动读取连接数据库的配置信息，而当前并没有配置，所以，就会出现错误！则需要在application.properties文件中添加配置<br>    spring.datasource.url=jdbc:mysql://localhost:3306/tedu_ums?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai<br>    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<br>    spring.datasource.username=root<br>    spring.datasource.password=root</p>
<p>  当添加了以上配置后，其实，启动项目时，也只是读取以上配置，并不会执行连接数据库的操作，所以，即使配置信息有误，也不会提示错误，则需要通过单元测试，尝试连接数据库，才能知道配置信息及相关涉及的jar包文件是否正确！</p>
<p>在SampleApplicationTests中添加连接数据库的测试方法：<br>    @Autowired<br>    private DataSource dataSource;</p>
<pre><code>@Test
public void getConnection() throws SQLException {
  System.err.println(dataSource.getConnection());
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/17/SpringBoot%E5%A4%8D%E4%B9%A0/" data-id="ckcq4we9t0000hwu34st0hxt0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringCloud的第一天学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/03/SpringCloud%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-03T06:45:07.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/03/SpringCloud%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B9%A0/">SpringCloud的第一天学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分布式核心概念"><a href="#分布式核心概念" class="headerlink" title="分布式核心概念"></a>分布式核心概念</h2><p>远程调用技术<br>   服务消费者与服务提供者简历链接<br>   流行的技术：rpc  http协议（无论什么语言都支持http协议）</p>
<p>  rpc：主要目标是让远程服务调用更简单，更透明，屏蔽底层的传输方式，一般用TCP或者UDP，开发者咋子使用的时候只需要了解谁在什么位置提供什么样的远程服务接口即可<br>       RESTful与rpc对比：<br>             通信协议：RESTful使用HTTP，RPC一般使用TCP<br>            性能：RESTful略低，RPC较高<br>            灵活度：RESTful高，RPC较低<br>            应用：RESTful用于微服务架构，PRC用于SOA架构</p>
<h2 id="分布式中的CAP原理"><a href="#分布式中的CAP原理" class="headerlink" title="分布式中的CAP原理"></a>分布式中的CAP原理</h2><p>  衡量分布式系统架构是否符合要求的一个重要指导方式，通过C一致性（保证时时刻刻多节点间的数据一致）、A可用性（节点是否可以正常提供数据给客户端）、P分区容忍性（是否容忍不数据存放在不同的数据节点上）来衡量架构<br>           C一致性：保持服务可用，通过多节点解决<br>           A可用性:多节点数据一致性<br>           P分区容忍性：是否可以将数据存放到多个地方</p>
<p>  一个系统中不可能同时满足C.A.P，衡量一般都是拿其中两项：ac，ap，cp，一般看具体应用，较多的用ap<br>          ac：考量一致性和可用性，物理数据库用的比较多<br>          ap：短暂允许数据不一致，NOsql数据库<br>          cp：zookeeper</p>
<h2 id="常见的微服务框架"><a href="#常见的微服务框架" class="headerlink" title="常见的微服务框架"></a>常见的微服务框架</h2><p>  Spring Cloud、ServiceComb、ZeroC ICE</p>
<h2 id="Springcloud"><a href="#Springcloud" class="headerlink" title="Springcloud"></a>Springcloud</h2><p>  Spring Cloud：利用了Spring Boot的开发便利性，简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，可以使用Spring Boot的开发风格做到一键部署与启动，不需要重复造轮子<br>  SpringCloud的架构：<br>         1、核心组件<br>         1、Netfix组件<br>             Eureka：服务注册中心<br>             Ribbon：客服端负载均衡<br>             Feign：声明式服务调用<br>             Hystrix：客户端容错保护<br>             Zuul：API服务网关<br>         2、Alibaba组件<br>             Nacos：服务注册中心<br>             Sentinel：客户端容错保护<br>         3、原生及其他组件<br>             Consul：服务注册中心<br>             Config：分布式配置中心<br>             Gateway：API服务网关<br>             Sleuth/Zipkin：分布式链路追踪</p>
<p>  服务注册中心：负责服务的注册与发现，很好的将服务连接起来<br>  断路器：负责监控服务之间的调用情况，连续多次失败进行熔断保护。<br>         API网关：负责转发所有对外的请求和服务<br>         配置中心：提供了同意的配置信息管理服务，可以实时的通知各个服务火气最新的配置信息</p>
<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>  Spring框架提供的类，可用于应用中调用rest服务，简化了http服务之间的通信方式，同意了RESTful标准，封装了http链接，我们只需要传入url以及返回值即可<br>  该类的方法：<br>  GET：getForObject（String,Class<T>,Object….）<br>  getForEntity（String,Class<T>,Object….）</p>
<p>  POST:postForlocation(String,Object,Class<T>,Object….)<br>         postForObject(String,Object,Class<T>,Object….)</p>
<p>  PUT:put(String,Object,Object….)</p>
<p>  DELETE:delete(String,Object….)</p>
<p>  HEAD:headForHeaders(String,Object….)</p>
<p>  OPTIONS:optionsForAllow(String,Object….)</p>
<p>  any:exchange(String,HttpMethod,HttpEntity&lt;?&gt;,Class<T>,Object…)<br>         execute(String,HttpMethod,RequestCallback,ResponseExtractor<T>,Objecr…)</p>
<p>  调用：<br>      1、在启动类配置RestTemplate</p>
<pre><code>//使用Spring提供的RestTemplate发送HTTP请求到商品服务
//1.创建RestTemplate对象交给容器管理
//2.在使用的时候，调用其方法完成操作（getxxx，postxxx）

        //配置RestTemplate交给spring管理
        @Bean
        public RestTemplate getRestTemplate(){
            return new RestTemplate();    
        }

 2、编写下订单方法（什么地方要用就在什么地方注入，注入到控制器即可）

        //注入RestTemplate对象
        @Autowired
        private RestTemplate restTemplate;

        @RequestMapping(value = &quot;/buy/{id}&quot;,method = RequestMethod.GET)
        public Product findById(@pathVariable long id){
            Product product = null;
            //调用商品服务
            //这里的url是你要调用的微服务中的url，要调用微服务A输入A的地址，调用B输入B的地址
            product = restTemplate.getForObject(url:&quot;http://xxx.x.x.xxx:端口号/xxx/id&quot;，Product.class)  
            return product;
        }</code></pre><p>  正常微服务调用时，通过RestTemplate，再输入微服务的url即可，但微服务的url改变后都会导致服务调用者也需要改变url，耦合度过大，所以加入API网关，调用时只需要调用网关就可以。<br>  其中一个微服务的配置文件如果进行修改，可能导致整个系统的所有配置都需要修改，所以需要进行配置统一管理。<br>  为了记录日志，正常的情况下，当微服务之间相互调用，会让日志过于分散，所以需要引入链路追踪，方便定位问题。</p>
<h2 id="微服务注册中心"><a href="#微服务注册中心" class="headerlink" title="微服务注册中心"></a>微服务注册中心</h2><p>  相当于微服务架构中的通讯录，他记录的服务和服务地址的映射关系，在分布式架构中，服务会到这里注册，当服务需要调用其他服务时，这里可以找到其他服务地址，以便于进行调用。</p>
<p>   注册中心的主要作用：<br>         1、服务发现：服务注册/反注册、服务订阅/取消订阅、服务路由（可选）<br>         2、服务配置：配置订阅、配置下发<br>         3、服务健康检测：检查服务提供者的健康情况。</p>
<p>   常见的注册中心：Zookeeper（cp）、Consul（cp）、Eureka（ap 常用）、Nacos（ap）</p>
<p>Eureka（高可用集群）<br>       由三个组成：Eureka Server（提供服务注册和发现）、Service Provider(服务提供方。将自身服务注册到Eureka，使服务消费方能够找到)、Service Consumer(服务消费方。从Eureka获取注册服务列表，从而消费服务)</p>
<p>  使用步骤：<br>         1、搭建Eureka Server<br>         1.1创建工程<br>         1.2导入依赖<br>         1.3配置配置文件<br>         1.4配置启动类<br>         2、将服务提供则注册到eureka Server上<br>         2.1引入EurekaClient的依赖<br>         2.2修改配置文件（服务提供者的），添加EurekaServer的信息<br>         2.3修改服务提供者启动类，添加服务发现的支持（可选）{新版Springcloud当配置完会自动将信息注册，不在服务提供者启动类写注解也可以}<br>         3、服务消费者通过注册中心获取服务列表并调用</p>
<p>  Eureka中的元数据：服务的主机名，ip等信息，通过eureka server进行获取，用于服务之间的调<br>  通过DiscoveryClient对象调用getInstances（“服务名称”）方法获得一个list返回值，再通过该返回值.get（0）获取一个ServiceInstance对象，这个对象的.getHost（）与.getPort方法可以分别获取主机地址与端口号，使得可以灵活改变微服务的地址与端口号</p>
<p>  Eureka高可用：可以制作多个Eureka，让其之间相互链接，如果第一个挂掉了，消费者通过第二个还可以接着访问微服务，不会让服务器直接宕机无法运行，而且当Eureka互相注册时，他们的信息会互相同步，但为了高可用，还是需要将服务注册到第二个Eureka，地址之间用“,”分开。<br>  操作：<br>       1、准备两个EurekaServer，需要互相注册（修改配置文件），1号Server：9000   2号Server：8000<br>       2、需要将微服务注册到两个EurekaServer上（修改配置文件）<br>  关于Eureka的配置，参考<a href="https://www.cnblogs.com/ouyida3/p/9747423.html" target="_blank" rel="noopener">https://www.cnblogs.com/ouyida3/p/9747423.html</a></p>
<p>  自我保护机制：检查其他的微服务、Eureka是否挂掉，检查服务是否有固定时间发心跳反应</p>
<p>  SpringBoot的自动装配：可以通过启动类会自动执行selectImports的特点，我们可以自己定义配置文件与SpringBoot中factory的配置文件（里面包含很多对象），可以通过该特点让框架帮我们创建对象。</p>
<p>  Eureka-Server的启动过程：通过Spring.factory中的配置创建EurekaController，配合页面完成相关功能，创建jerseyApplication，借助这个找到@Path、@Provider发布web接口让EurekaClient调用</p>
<p>  图片：<br>     链接：<a href="https://pan.baidu.com/s/1FzxXNLBmqL6af3T_RIZmng" target="_blank" rel="noopener">https://pan.baidu.com/s/1FzxXNLBmqL6af3T_RIZmng</a><br>     提取码：gkb3</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/03/SpringCloud%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%AD%A6%E4%B9%A0/" data-id="ckc5veq7600007su3823laoam" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="n-重装系统后重新整理的hexo以及git的遇到的问题" class="article article-type-n" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/01/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%9A%84hexo%E4%BB%A5%E5%8F%8Agit%E7%9A%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-06-30T16:37:59.000Z" itemprop="datePublished">2020-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/01/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%9A%84hexo%E4%BB%A5%E5%8F%8Agit%E7%9A%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">重装系统后重新整理的hexo以及git的遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于git的"><a href="#关于git的" class="headerlink" title="关于git的"></a>关于git的</h2><p>   由于前阶段因为考试太久没整理电脑以及对编程的学习，很多东西都忘了一部分了，所以熟能生巧很重要。之前电脑重装完，这几天重新整理好了环境变量以及开发工具，然后复习之前的内容。昨天重装了git，然后也重新复习了一遍。</p>
<p>   关于git的使用<br>   先在远端创建好仓库，然后git clone 地址   将仓库克隆到本地<br>   分为四步走<br>   1、touch 文件名               –》创建文件，也可以直接在文件夹创建<br>   2、git add 文件名            –》将文件从工作区添加到暂存区<br>   3、git commit -m ‘描述内容’    –》将暂存区域添加到本地仓库，填写的描述内容表示本次的操作是对文件的处理<br>   4、git push                  –》将文件提交到远端仓库</p>
<p>   修改文件也是同样的，修改文件会将文件转义到工作区，所以当编辑完文件后，就需要从新从第二步开始，从新提交</p>
<h2 id="关于hexo博客框架的"><a href="#关于hexo博客框架的" class="headerlink" title="关于hexo博客框架的"></a>关于hexo博客框架的</h2><p>   这次的博客框架出现了一个BUG，页面没有渲染（partial转义失败）,导致显示只会显示出一部分混乱的HTML，这时候需要重新安装一个插件，由于我使用的是淘宝的镜像，使用的是cnpm，所以对应的需要用的命令是“cnpm install”。<br>   还有就是hexo框架支持Markdown语法，但是我电脑上没有相关的软件，只能用EverEdit来对博客文章内容编写，无法插入图片，需要学习一下Markdown语法。</p>
<p>   这几天先整理一下之前学习的内容，巩固一下对于数据库SQL优化相关的内容以及后面的关于MQ、redis这些内容，这周要把Docker看一下，以及重新制作一下之前的项目，电脑重装后数据库没做备份处理，导致之前项目的数据内容全部丢失，需要重新整理一遍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/01/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%9A%84hexo%E4%BB%A5%E5%8F%8Agit%E7%9A%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="ckc277fps000044u3fmk518vw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/hello-world/" class="article-date">
  <time datetime="2020-06-30T13:29:28.194Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/hello-world/" data-id="ckc1z3i060000awu3hgt795r7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MQ中间件的学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/MQ%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-04-27T05:35:11.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/MQ%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/">MQ中间件的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="消息队列有什么优点和缺点"><a href="#消息队列有什么优点和缺点" class="headerlink" title="消息队列有什么优点和缺点?"></a>消息队列有什么优点和缺点?</h2><p>为什么使用消息队列?假设你的业务场景遇到个技术挑战，如果不用 MQ 可能会很麻烦，但是你用了 MQ 之后会带给你很多好处。</p>
<p>消息队列 MQ 的常见使用场景其实有很多，但是比较核心的有如下三个：</p>
<p>解耦<br>异步<br>削峰<br>解耦：A 系统发送个数据到 BCD 三个系统，接口调用发送，那如果 E 系统也要这个数据呢?那如果 C 系统现在不需要了呢?</p>
<p>现在 A 系统又要发送第二种数据了呢?而且 A 系统要时时刻刻考虑 BCDE 四个系统如果挂了咋办?要不要重发?我要不要把消息存起来?</p>
<p>你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。</p>
<p>但是，这个调用是不需要直接同步调用接口的，如果用 MQ 给他异步化解耦，也是可以的。你就只需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。</p>
<p>异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 30ms，BCD 三个系统分别写库要 300ms、450ms、200ms。</p>
<p>最终请求总延时是 30 + 300 + 450 + 200 = 980ms，接近 1s，异步后，BCD 三个系统分别写库的时间，A 系统就不再考虑了。</p>
<p>削峰：每天 0 点到 16 点，A 系统风平浪静，每秒并发请求数量就 100 个。结果每次一到 16 点~23 点，每秒并发请求数量突然会暴增到 10000 条。</p>
<p>但是系统最大的处理能力就只能是每秒钟处理 1000 个请求啊。怎么办?需要我们进行流量的削峰，让系统可以平缓的处理突增的请求。</p>
<p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰，那么消息队列有什么缺点?</p>
<p>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是 A 系统调用 BCD 三个系统的接口就好了。</p>
<p>ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了怎么办?MQ 挂了，整套系统崩溃了，业务也就停顿了。</p>
<p>系统复杂性提高：硬生生加个 MQ 进来，怎么保证消息没有重复消费?怎么处理消息丢失的情况?怎么保证消息传递的顺序性?</p>
<p>一致性问题：A 系统处理完了直接返回成功了，大家都以为你这个请求就成功了。</p>
<p>但问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，你这数据就不一致了。</p>
<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉。</p>
<p>常见消息队列的比较如下图：</p>
<p>如何解决重复消费?</p>
<p>消息重复的原因</p>
<p>消息发送端应用的消息重复发送，有以下几种情况：</p>
<p>消息发送端发送消息给消息中间件，消息中间件收到消息并成功存储，而这时消息中间件出现了问题，导致应用端没有收到消息发送成功的返回因而进行重试产生了重复。<br>消息中间件因为负载高响应变慢，成功把消息存储到消息存储中后，返回“成功”这个结果时超时。<br>消息中间件将消息成功写入消息存储，在返回结果时网络出现问题，导致应用发送端重试，而重试时网络恢复，由此导致重复。<br>可以看到，通过消息发送端产生消息重复的主要原因是消息成功进入消息存储后，因为各种原因使得消息发送端没有收到“成功”的返回结果，并且又有重试机制，因而导致重复。</p>
<p>消息到达了消息存储，由消息中间件进行向外的投递时产生重复，有以下几种情况：</p>
<p>消息被投递到消息接收者应用进行处理，处理完毕后应用出问题了，消息中间件不知道消息处理结果，会再次投递。<br>消息被投递到消息接收者应用进行处理，处理完毕后网络出现问题了，消息中间件没有收到消息处理结果，会再次投递。<br>消息被投递到消息接收者应用进行处理，处理时间比较长，消息中间件因为消息超时会再次投递。<br>消息被投递到消息接收者应用进行处理，处理完毕后消息中间件出问题了,没能收到消息结果并处理，会再次投递。<br>消息被投递到消息接收者应用进行处理，处理完毕后消息中间件收到结果但是遇到消息存储故障，没能更新投递状态，会再次投递。<br>可以看到，在投递过程中产生的消息重复接收主要是因为消息接收者成功处理完消息后，消息中间件不能及时更新投递状态造成的。</p>
<p>如何解决重复消费</p>
<p>那么有什么办法可以解决呢?主要是要求消息接收者来处理这种重复的情况，也就是要求消息接收者的消息处理是幂等操作。</p>
<p>什么是幂等性?对于消息接收端的情况，幂等的含义是采用同样的输入多次调用处理函数，得到同样的结果。</p>
<p>例如，一个 SQL 操作：</p>
<p>update stat_table set count= 10 where id =1<br>这个操作多次执行，id 等于 1 的记录中的 count 字段的值都为 10，这个操作就是幂等的，我们不用担心这个操作被重复。</p>
<p>再来看另外一个 SQL 操作：</p>
<p>update stat_table set count= count +1 where id= 1;<br>这样的 SQL 操作就不是幂等的，一旦重复，结果就会产生变化。</p>
<p>因此应对消息重复的办法是使消息接收端的处理是一个幂等操作。这样的做法降低了消息中间件的整体复杂性，不过也给使用消息中间件的消息接收端应用带来了一定的限制和门槛。</p>
<p>①MVCC</p>
<p>多版本并发控制，乐观锁的一种实现，在生产者发送消息时进行数据更新时需要带上数据的版本号，消费者去更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功。</p>
<p>例如博客点赞次数自动 +1 的接口：</p>
<p>public boolean addCount(Long id, Long version);<br>update blogTable set count= count+1,version=version+1 where id=321 and version=123<br>每一个 version 只有一次执行成功的机会，一旦失败了生产者必须重新获取数据的最新版本号再次发起更新。</p>
<p>②去重表</p>
<p>利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求不再重复处理了(利用一张日志表来记录已经处理成功的消息的 id，如果新到的消息 id 已经在日志表中，那么就不再处理这条消息。)</p>
<p>以电商平台为例子，电商平台上的订单 id 就是最适合的 token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。</p>
<p>每一个环节执行时都先检测一下该订单 id 是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的 id，则直接返回之前的执行结果，不做任何操作。</p>
<p>这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。</p>
<p>如何保证消息的可靠性传输?</p>
<p>ActiveMQ</p>
<p>要保证消息的可靠性，除了消息的持久化，还包括两个方面：</p>
<p>生产者发送的消息可以被 ActiveMQ 收到。<br>消费者收到了 ActiveMQ 发送的消息。<br>①生产者</p>
<p>非持久化又不在事务中的消息，可能会有消息的丢失。为保证消息可以被 ActiveMQ 收到，我们应该采用事务消息或持久化消息。</p>
<p>②消费者</p>
<p>消费者对消息的确认有四种机制：</p>
<p>AUTO_ACKNOWLEDGE=1：自动确认<br>CLIENT_ACKNOWLEDGE=2：客户端手动确认<br>DUPS_OK_ACKNOWLEDGE=3：自动批量确认<br>SESSION_TRANSACTED=0：事务提交并确认<br>ACK_MODE 描述了 Consumer 与 Broker 确认消息的方式(时机)，比如当消息被 Consumer 接收之后，Consumer 将在何时确认消息。</p>
<p>所以 ack_mode 描述的不是 Producer 与 Broker 之间的关系，而是 Customer 与 Broker 之间的关系。</p>
<p>对于 Broker 而言，只有接收到 ACK 指令，才会认为消息被正确的接收或者处理成功了。通过 ACK，可以在 Consumer 与 Broker 之间建立一种简单的“担保”机制。</p>
<p>AUTO_ACKNOWLEDGE：自动确认，“同步”(receive)方法返回 message 给消息时会立即确认。</p>
<p>在”异步”(messageListener)方式中，将会首先调用listener.onMessage(message)。</p>
<p>如果 onMessage 方法正常结束，消息将会正常确认;如果 onMessage 方法异常，将导致消费者要求 ActiveMQ 重发消息。</p>
<p>CLIENT_ACKNOWLEDGE：客户端手动确认，这就意味着 AcitveMQ 将不会“自作主张”的为你 ACK 任何消息，开发者需要自己择机确认。</p>
<p>我们可以在当前消息处理成功之后，立即调用 message.acknowledge() 方法来”逐个”确认消息，这样可以尽可能的减少因网络故障而导致消息重发的个数。</p>
<p>当然也可以处理多条消息之后，间歇性的调用 ACKNOWLEDGE 方法来一次确认多条消息，减少 ACK 的次数来提升 Consumer 的效率，不过需要自行权衡。</p>
<p>DUPS_OK_ACKNOWLEDGE：类似于 AUTO_ACK 确认机制，为自动批量确认而生，而且具有“延迟”确认的特点，ActiveMQ 会根据内部算法，在收到一定数量的消息自动进行确认。</p>
<p>在此模式下，可能会出现重复消息，什么时候?当 Consumer 故障重启后，那些尚未 ACK 的消息会重新发送过来。</p>
<p>SESSION_TRANSACTED：当 Session 使用事务时，就是使用此模式。当决定事务中的消息可以确认时，必须调用 session.commit() 方法，Commit 方法将会导致当前 Session 的事务中所有消息立即被确认。</p>
<p>在事务开始之后的任何时机调用 rollback()，意味着当前事务的结束，事务中所有的消息都将被重发。当然在 Commit 之前抛出异常，也会导致事务的 rollback。</p>
<p>RabbitMQ</p>
<p>①生产者弄丢了数据</p>
<p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。</p>
<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务(channel.txSelect)，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错。</p>
<p>此时就可以回滚事务(channel.txRollback)，然后重试发送消息;如果收到了消息，那么可以提交事务(channel.txCommit)。</p>
<p>但是问题是，RabbitMQ 事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p>
<p>所以一般来说，如果要确保 RabbitMQ 的消息别丢，可以开启 Confirm 模式。</p>
<p>在生产者那里设置开启 Confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ACK 消息，告诉你说这个消息 OK 了。</p>
<p>如果 RabbitMQ 没能处理这个消息，会回调你一个 nack 接口，告诉你这个消息接收失败，你可以重试。</p>
<p>而且你可以结合这个机制，自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
<p>事务机制和 Cnofirm 机制最大的不同在于：事务机制是同步的，你提交一个事务之后会阻塞在那儿。</p>
<p>但是 Confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你一个接口通知你这个消息接收到了。</p>
<p>所以一般在生产者这块避免数据丢失，都是用 Confirm 机制的。</p>
<p>②RabbitMQ 弄丢了数据</p>
<p>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。</p>
<p>除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p>
<p>设置持久化有两个步骤：</p>
<p>创建 queue 和交换器的时候将其设置为持久化的，这样就可以保证 RabbitMQ 持久化相关的元数据，但是不会持久化 queue 里的数据。<br>发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。<br>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p>
<p>而且持久化可以跟生产者那边的 Confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ACK 了。</p>
<p>所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ACK，你也是可以自己重发的。</p>
<p>哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据会丢失。</p>
<p>③消费端弄丢了数据</p>
<p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>
<p>这个时候得用 RabbitMQ 提供的 ACK 机制，简单来说，就是你关闭 RabbitMQ 自动 ACK，可以通过一个 API 来调用就行，然后每次你自己代码里确保处理完的时候，再程序里 ACK 一把。</p>
<p>这样的话，如果你还没处理完，不就没有 ACK?那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 Consumer 去处理，消息是不会丢的。</p>
<p>Kafka</p>
<p>①消费端弄丢了数据</p>
<p>唯一可能导致消费者弄丢数据的情况，就是说，你那个消费到了这个消息，然后消费者那边自动提交了 Offset，让 Kafka 以为你已经消费好了这个消息。</p>
<p>其实你刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>
<p>大家都知道 Kafka 会自动提交 Offset，那么只要关闭自动提交 Offset，在处理完之后自己手动提交 Offset，就可以保证数据不会丢。</p>
<p>但是此时确实还是会重复消费，比如你刚处理完，还没提交 Offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p>
<p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 Offset。</p>
<p>然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p>
<p>②Kafka 弄丢了数据</p>
<p>这块比较常见的一个场景，就是 Kafka 某个 Broker 宕机，然后重新选举 Partition 的 Leader 时。</p>
<p>大家想想，要是此时其他的 Follower 刚好还有些数据没有同步，结果此时 Leader 挂了，然后选举某个 Follower 成 Leader 之后，他不就少了一些数据?这就丢了一些数据啊。</p>
<p>所以此时一般是要求起码设置如下四个参数：</p>
<p>给这个 Topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 Partition 必须有至少 2 个副本。<br>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 Leader 至少感知到有至少一个 Follower 还跟自己保持联系，没掉队，这样才能确保 Leader 挂了还有一个 Follower 吧。<br>在 Producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 Replica 之后，才能认为是写成功了。<br>在 Producer 端设置 retries=MAX(很大很大很大的一个值，无限次重试的意思)：这个是要求一旦写入失败，就无限重试，卡在这里了。<br>③生产者会不会弄丢数据</p>
<p>如果按照上述的思路设置了 ack=all，一定不会丢，要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<p>消息的顺序性</p>
<p>从根本上说，异步消息是不应该有顺序依赖的，在 MQ 上估计是没法解决。</p>
<p>要实现严格的顺序消息，简单且可行的办法就是：保证生产者、MQServer、消费者是一对一对一的关系。</p>
<p>ActiveMQ</p>
<p>①通过高级特性 Consumer 独有消费者(exclusive consumer)</p>
<p>queue = new ActiveMQQueue(“TEST.QUEUE?consumer.exclusive=true”);<br>consumer = session.createConsumer(queue);<br>当在接收信息的时候，有多个独占消费者的时候，只有一个独占消费者可以接收到消息。</p>
<p>独占消息就是在有多个消费者同时消费一个 queue 时，可以保证只有一个消费者可以消费消息。</p>
<p>这样虽然保证了消息的顺序问题，不过也带来了一个问题，就是这个 queue 的所有消息将只会在这一个主消费者上消费，其他消费者将闲置，达不到负载均衡分配。</p>
<p>而实际业务我们可能更多的是这样的场景，比如一个订单会发出一组顺序消息，我们只要求这一组消息是顺序消费的，而订单与订单之间又是可以并行消费的，不需要顺序，因为顺序也没有任何意义。</p>
<p>有没有办法做到呢?可以利用 ActiveMQ 的另一个高级特性之 messageGroup。</p>
<p>②利用 ActiveMQ 的高级特性：Message Groups</p>
<p>Message Groups 特性是一种负载均衡的机制。在一个消息被分发到 Consumer 之前，Broker 首先检查消息 JMSXGroupID 属性。</p>
<p>如果存在，那么 Broker 会检查是否有某个 Consumer 拥有这个 Message Group。</p>
<p>如果没有，那么 Broker 会选择一个 Consumer，并将它关联到这个 Message Group。</p>
<p>此后，这个 Consumer 会接收这个 Message Group 的所有消息，直到 Consumer 被关闭。</p>
<p>Message Group 被关闭，通过发送一个消息，并设置这个消息的 JMSXGroupSeq 为 -1。</p>
<p>bytesMessage.setStringProperty(“JMSXGroupID”, “constact-20100000002”);<br>bytesMessage.setIntProperty(“JMSXGroupSeq”, -1);<br>如上图所示，同一个 queue 中，拥有相同 JMSXGroupID 的消息将发往同一个消费者，解决顺序问题;不同分组的消息又能被其他消费者并行消费，解决负载均衡的问题。</p>
<p>RabbitMQ</p>
<p>如果有顺序依赖的消息，要保证消息有一个 hashKey，类似于数据库表分区的的分区 key 列。保证对同一个 key 的消息发送到相同的队列。</p>
<p>A 用户产生的消息(包括创建消息和删除消息)都按 A 的 hashKey 分发到同一个队列。</p>
<p>只需要把强相关的两条消息基于相同的路由就行了，也就是说经过 m1 和 m2 的在路由表里的路由是一样的，那自然 m1 会优先于 m2 去投递。而且一个 queue 只对应一个 Consumer。</p>
<p>Kafka</p>
<p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费。</p>
<p>如何解决消息队列的延时以及过期失效问题?RabbitMQ 是可以设置过期时间的，就是 TTL。</p>
<p>如果消息在 queue 中积压超过一定的时间，而又没有设置死信队列机制，就会被 RabbitMQ 给清理掉，这个数据就没了。ActiveMQ 则通过更改配置，支持消息的定时发送。</p>
<p>有几百万消息持续积压几小时怎么解决?</p>
<p>发生了线上故障，几千万条数据在 MQ 里积压很久。是修复 Consumer 的问题，让他恢复消费速度，然后等待几个小时消费完毕?这是个解决方案，不过有时候我们还会进行临时紧急扩容。</p>
<p>一个消费者一秒是 1000 条，3 个消费者一秒是 3000 条，一分钟是 18 万条。</p>
<p>所以如果积压了几百万到上千万的数据，即使消费者恢复了，也需要大概一小时的时间才能恢复过来。</p>
<p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：</p>
<p>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。<br>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍或者 20 倍的 queue 数量。<br>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</p>
<p>接着临时征用 10 倍的机器来部署 Consumer，每一批 Consumer 消费一个临时 queue 的数据。<br>这种做法相当于是临时将 queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，再恢复原先部署架构，重新用原先的 Consumer 机器来消费消息。<br>Kafka是如何实现高性能的?</p>
<p>①宏观架构层面利用 Partition 实现并行处理</p>
<p>Kafka 中每个 Topic 都包含一个或多个 Partition，不同 Partition 可位于不同节点。</p>
<p>同时 Partition 在物理上对应一个本地文件夹，每个 Partition 包含一个或多个 Segment，每个 Segment 包含一个数据文件和一个与之对应的索引文件。</p>
<p>在逻辑上，可以把一个 Partition 当作一个非常长的数组，可通过这个“数组”的索引(Offset)去访问其数据。</p>
<p>一方面，由于不同 Partition 可位于不同机器，因此可以充分利用集群优势，实现机器间的并行处理。</p>
<p>另一方面，由于 Partition 在物理上对应一个文件夹，即使多个 Partition 位于同一个节点，也可通过配置让同一节点上的不同 Partition 置于不同的 disk drive 上，从而实现磁盘间的并行处理，充分发挥多磁盘的优势。</p>
<p>利用多磁盘的具体方法是，将不同磁盘 mount 到不同目录，然后在 server.properties 中，将 log.dirs 设置为多目录(用逗号分隔)。</p>
<p>Kafka 会自动将所有 Partition 尽可能均匀分配到不同目录也即不同目录(也即不同 disk)上。</p>
<p>Partition 是最小并发粒度，Partition 个数决定了可能的最大并行度。</p>
<p>②ISR 实现可用性与数据一致性的动态平衡</p>
<p>常用数据复制及一致性方案有如下几种：</p>
<p>Master-Slave：</p>
<p>RDBMS 的读写分离即为典型的 Master-Slave 方案。<br>同步复制可保证强一致性但会影响可用性。<br>异步复制可提供高可用性但会降低一致性。<br>WNR：</p>
<p>主要用于去中心化的分布式系统中。<br>N 代表总副本数，W 代表每次写操作要保证的最少写成功的副本数，R 代表每次读至少要读取的副本数。<br>当 W+R&gt;N 时，可保证每次读取的数据至少有一个副本拥有最新的数据。<br>多个写操作的顺序难以保证，可能导致多副本间的写操作顺序不一致。Dynamo 通过向量时钟保证最终一致性。<br>Paxos 及其变种：</p>
<p>Google 的 Chubby，Zookeeper 的原子广播协议(Zab)，RAFT 等。<br>基于 ISR 的数据复制方案：Kafka 的数据复制是以 Partition 为单位的。而多个备份间的数据复制，通过 Follower 向 Leader 拉取数据完成。</p>
<p>从这一点来讲，Kafka 的数据复制方案接近于上文所讲的 Master-Slave 方案。</p>
<p>不同的是，Kafka 既不是完全的同步复制，也不是完全的异步复制，而是基于 ISR 的动态复制方案。</p>
<p>ISR，也即 In-Sync Replica。每个 Partition 的 Leader 都会维护这样一个列表，该列表中，包含了所有与之同步的 Replica(包含 Leader 自己)。</p>
<p>每次数据写入时，只有 ISR 中的所有 Replica 都复制完，Leader 才会将其置为 Commit，它才能被 Consumer 所消费。</p>
<p>这种方案，与同步复制非常接近。但不同的是，这个 ISR 是由 Leader 动态维护的。</p>
<p>如果 Follower 不能紧“跟上”Leader，它将被 Leader 从 ISR 中移除，待它又重新“跟上”Leader 后，会被 Leader 再次加到 ISR 中。每次改变 ISR 后，Leader 都会将最新的 ISR 持久化到 Zookeeper 中。</p>
<p>由于 Leader 可移除不能及时与之同步的 Follower，故与同步复制相比可避免最慢的 Follower 拖慢整体速度，也即 ISR 提高了系统可用性。</p>
<p>ISR 中的所有 Follower 都包含了所有 Commit 过的消息，而只有 Commit 过的消息才会被 Consumer 消费。</p>
<p>故从 Consumer 的角度而言，ISR 中的所有 Replica 都始终处于同步状态，从而与异步复制方案相比提高了数据一致性。</p>
<p>ISR 可动态调整，极限情况下，可以只包含 Leader，极大提高了可容忍的宕机的 Follower 的数量。</p>
<p>与 Majority Quorum 方案相比，容忍相同个数的节点失败，所要求的总节点数少了近一半。</p>
<p>③具体实现层面高效使用磁盘特性和操作系统特性</p>
<p>将写磁盘的过程变为顺序写</p>
<p>Kafka 的整个设计中，Partition 相当于一个非常长的数组，而 Broker 接收到的所有消息顺序写入这个大数组中。</p>
<p>同时 Consumer 通过 Offset 顺序消费这些数据，并且不删除已经消费的数据，从而避免了随机写磁盘的过程。</p>
<p>由于磁盘有限，不可能保存所有数据，实际上作为消息系统 Kafka 也没必要保存所有数据，需要删除旧的数据。</p>
<p>而这个删除过程，并非通过使用“读-写”模式去修改文件，而是将 Partition 分为多个 Segment，每个 Segment 对应一个物理文件，通过删除整个文件的方式去删除 Partition 内的数据。</p>
<p>这种方式清除旧数据的方式，也避免了对文件的随机写操作。在存储机制上，使用了 Log Structured Merge Trees(LSM) 。</p>
<p>注：Log Structured Merge Trees(LSM)，谷歌 “BigTable” 的论文中提出，LSM 是当前被用在许多产品的文件结构策略：HBase，Cassandra，LevelDB，SQLite，Kafka。</p>
<p>LSM 被设计来提供比传统的 B+ 树或者 ISAM 更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。</p>
<p>这个问题的本质还是磁盘随机操作慢，顺序读写快。这两种操作存在巨大的差距，无论是磁盘还是 SSD，而且快至少三个数量级。</p>
<p>充分利用 Page Cache</p>
<p>使用 Page Cache 的好处如下：</p>
<p>I/O Scheduler 会将连续的小块写组装成大块的物理写从而提高性能。<br>I/O Scheduler 会尝试将一些写操作重新按顺序排好，从而减少磁盘头的移动时间。<br>充分利用所有空闲内存(非 JVM 内存)。如果使用应用层 Cache(即 JVM 堆内存)，会增加 GC 负担。<br>读操作可直接在 Page Cache 内进行。如果消费和生产速度相当，甚至不需要通过物理磁盘(直接通过 Page Cache)交换数据。<br>如果进程重启，JVM 内的 Cache 会失效，但 Page Cache 仍然可用。<br>Broker 收到数据后，写磁盘时只是将数据写入 Page Cache，并不保证数据一定完全写入磁盘。</p>
<p>从这一点看，可能会造成机器宕机时，Page Cache 内的数据未写入磁盘从而造成数据丢失。</p>
<p>但是这种丢失只发生在机器断电等造成操作系统不工作的场景，而这种场景完全可以由 Kafka 层面的 Replication 机制去解决。</p>
<p>如果为了保证这种情况下数据不丢失而强制将 Page Cache 中的数据 Flush 到磁盘，反而会降低性能。</p>
<p>也正因如此，Kafka 虽然提供了 flush.messages 和 flush.ms 两个参数将 Page Cache 中的数据强制 Flush 到磁盘，但是 Kafka 并不建议使用。</p>
<p>如果数据消费速度与生产速度相当，甚至不需要通过物理磁盘交换数据，而是直接通过 Page Cache 交换数据。同时，Follower 从 Leader Fetch 数据时，也可通过 Page Cache 完成。</p>
<p>注：Page Cache，又称 pcache，其中文名称为页高速缓冲存储器，简称页高缓。</p>
<p>Page Cache 的大小为一页，通常为 4K。在 Linux 读写文件时，它用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问。 这是 Linux 操作系统的一个特色。</p>
<p>支持多 Disk Drive</p>
<p>Broker 的 log.dirs 配置项，允许配置多个文件夹。如果机器上有多个 Disk Drive，可将不同的 Disk 挂载到不同的目录，然后将这些目录都配置到 log.dirs 里。</p>
<p>Kafka 会尽可能将不同的 Partition 分配到不同的目录，也即不同的 Disk 上，从而充分利用了多 Disk 的优势。</p>
<p>零拷贝</p>
<p>Kafka 中存在大量的网络数据持久化到磁盘(Producer 到 Broker)和磁盘文件通过网络发送(Broker 到 Consumer)的过程。这一过程的性能直接影响 Kafka 的整体吞吐量。</p>
<p>传统模式下的四次拷贝与四次上下文切换，以将磁盘文件通过网络发送为例。</p>
<p>传统模式下，一般使用如下伪代码所示的方法先将文件数据读入内存，然后通过 Socket 将内存中的数据发送出去。</p>
<p>buffer = File.readSocket.send(buffer)<br>这一过程实际上发生了四次数据拷贝：</p>
<p>首先通过系统调用将文件数据读入到内核态 Buffer(DMA 拷贝)。<br>然后应用程序将内存态 Buffer 数据读入到用户态 Buffer(CPU 拷贝)。<br>接着用户程序通过 Socket 发送数据时将用户态 Buffer 数据拷贝到内核态 Buffer(CPU 拷贝)。<br>最后通过 DMA 拷贝将数据拷贝到 NIC Buffer。同时，还伴随着四次上下文切换。<br>而 Linux 2.4+ 内核通过 sendfile 系统调用，提供了零拷贝。数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer，无需 CPU 拷贝。这也是零拷贝这一说法的来源。</p>
<p>除了减少数据拷贝外，因为整个读文件-网络发送由一个 sendfile 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。</p>
<p>从具体实现来看，Kafka 的数据传输通过 Java NIO 的 FileChannel 的 transferTo 和 transferFrom 方法实现零拷贝。</p>
<p>注： transferTo 和 transferFrom 并不保证一定能使用零拷贝。实际上是否能使用零拷贝与操作系统相关，如果操作系统提供 sendfile 这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。</p>
<p>减少网络开销批处理</p>
<p>批处理是一种常用的用于提高 I/O 性能的方式。对 Kafka 而言，批处理既减少了网络传输的 Overhead，又提高了写磁盘的效率。</p>
<p>Kafka 的 send 方法并非立即将消息发送出去，而是通过 batch.size 和 linger.ms 控制实际发送频率，从而实现批量发送。</p>
<p>由于每次网络传输，除了传输消息本身以外，还要传输非常多的网络协议本身的一些内容(称为 Overhead)，所以将多条消息合并到一起传输，可有效减少网络传输的 Overhead，进而提高了传输效率。</p>
<p>数据压缩降低网络负载</p>
<p>Kafka 从 0.7 开始，即支持将数据压缩后再传输给 Broker。除了可以将每条消息单独压缩然后传输外，Kafka 还支持在批量发送时，将整个 Batch 的消息一起压缩后传输。</p>
<p>数据压缩的一个基本原理是，重复数据越多压缩效果越好。因此将整个 Batch 的数据一起压缩能更大幅度减小数据量，从而更大程度提高网络传输效率。</p>
<p>Broker 接收消息后，并不直接解压缩，而是直接将消息以压缩后的形式持久化到磁盘。Consumer Fetch 到数据后再解压缩。</p>
<p>因此 Kafka 的压缩不仅减少了 Producer 到 Broker 的网络传输负载，同时也降低了 Broker 磁盘操作的负载，也降低了 Consumer 与 Broker 间的网络传输量，从而极大得提高了传输效率，提高了吞吐量。</p>
<p>高效的序列化方式</p>
<p>Kafka 消息的 Key 和 Payload(或者说 Value)的类型可自定义，只需同时提供相应的序列化器和反序列化器即可。</p>
<p>因此用户可以通过使用快速且紧凑的序列化-反序列化方式(如 Avro，Protocal Buffer)来减少实际网络传输和磁盘存储的数据规模，从而提高吞吐率。</p>
<p>这里要注意，如果使用的序列化方法太慢，即使压缩比非常高，最终的效率也不一定高。</p>
<p>参考文献：csdn “hellozhxy’”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/27/MQ%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="ckc1zclqx0001w8u3c25k9w13" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/09/%E5%85%B3%E4%BA%8ESimBot%E7%9A%84%E5%AD%A6%E4%B9%A0/">关于SimBot的学习</a>
          </li>
        
          <li>
            <a href="/2020/07/30/%E2%80%9CVUE%E7%9A%84%E5%AD%A6%E4%B9%A0/">“VUE的学习</a>
          </li>
        
          <li>
            <a href="/2020/07/26/swagger%E7%9A%84%E5%AD%A6%E4%B9%A0/">swagger的学习</a>
          </li>
        
          <li>
            <a href="/2020/07/20/MyBatisPlus%E5%A4%8D%E4%B9%A0/">MyBatisplus复习</a>
          </li>
        
          <li>
            <a href="/2020/07/18/MySQL%E7%9A%84%E5%A4%8D%E4%B9%A0/">MySQL的复习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>